#ifndef UTILITIES_H
#define UTILITIES_H

#include "Node.h"

namespace pf
{
	/////////////////////////////////////////////////////////////////
	/// \brief Computes distance between START and END Point with Euclidean formula.
	/////////////////////////////////////////////////////////////////
	float distanceEuclidean(Point, Point);

	/////////////////////////////////////////////////////////////////
	/// \brief Computes distance between START and END Point with Manhattan formula.
	/////////////////////////////////////////////////////////////////
	int distanceManhattan(Point, Point);

	/////////////////////////////////////////////////////////////////
	/// \brief Sets all Nodes in the grid to default state.
	/////////////////////////////////////////////////////////////////
	void defaultGrid(std::vector<std::vector<Node>> &);

	/////////////////////////////////////////////////////////////////
	/// \brief Sets all Nodes in the grid to passable state.
	/////////////////////////////////////////////////////////////////
	void passableGrid(std::vector<std::vector<Node>> &);

	/////////////////////////////////////////////////////////////////
	/// \brief Initialize default grid in relation to the window resolution.
	/////////////////////////////////////////////////////////////////
	void initGrid(std::vector<std::vector<Node>> &, const sf::RenderWindow &);

	/////////////////////////////////////////////////////////////////
	/// \brief Prints grid.
	/////////////////////////////////////////////////////////////////
	inline void drawGrid(const std::vector<std::vector<Node>> &grid, sf::RenderWindow &window)
	{
		std::vector<std::vector<Node>>::const_iterator G_It;
		std::vector<Node>::const_iterator g_It;

		for (G_It = grid.begin(); G_It != grid.end(); G_It++)
			for (g_It = G_It->begin(); g_It != G_It->end(); g_It++)
				window.draw(*g_It);
	}

	/////////////////////////////////////////////////////////////////
	/// \brief Returns pointer to Node on the open list which points to Node on the grid with least cost (f).
	/////////////////////////////////////////////////////////////////
	Node* leastF(const std::vector<Node*> &);

	/////////////////////////////////////////////////////////////////
	/// \brief Finds and removes Node (q) from list.
	/////////////////////////////////////////////////////////////////
	void removeNode(std::vector<Node*> &, const Node *);

	/////////////////////////////////////////////////////////////////
	/// \brief Fills vector of Points with allowed directions (8).
	/////////////////////////////////////////////////////////////////
	void Dirs8(std::vector<Point> &);

	/////////////////////////////////////////////////////////////////
	/// \brief Fills vector of Points with allowed directions (4).
	/////////////////////////////////////////////////////////////////
	void Dirs4(std::vector<Point> &);

	/////////////////////////////////////////////////////////////////
	/// \brief Generates 'q's successors from directions vector and checks the type of that successor on grid.
	/////////////////////////////////////////////////////////////////
	void generateSuccessors(std::vector<std::vector<Node>> &, std::vector<Point> &, Node *, std::vector<Node *> &);

	/////////////////////////////////////////////////////////////////
	/// \brief Finds Node on vector with given position.
	/////////////////////////////////////////////////////////////////
	std::vector<Node *>::iterator findNode(std::vector<Node *> &, const Point &);

	/////////////////////////////////////////////////////////////////
	/// \brief Searches Node with same position as given Node, and replaces it with given Node if found.
	/////////////////////////////////////////////////////////////////
	void replaceNode(std::vector<Node *> &, Node &);

	/////////////////////////////////////////////////////////////////
	/// \brief Draws calcucated path.
	/////////////////////////////////////////////////////////////////
	void drawPath(Node *);
}

#endif // !UTILITIES_H

